{"./":{"url":"./","title":"找工作准备","keywords":"","body":"Introduction Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-06 09:59:52 "},"chapter1/section1/":{"url":"chapter1/section1/","title":"2022.02.14","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 计算机存储系统分为几个层次,你是如何理解分层存储的？ 多线程同步和互斥有几种实现方法，都是什么？ mysql中innodb和myisam的区别 InnoDB为什么推荐使用自增ID作为主键？ innodb引擎的4大特性 JDK为我们提供的工具 delete与truncate删除表中数据的区别 MD5是不是杂凑算法 数组的复制 并发操作可能会产生哪几类数据不一致？用什么方法能避免各种不一致的情况？ java对象序列化 slf4j实现原理 存储过程接受的参数是： PL/SQL 磁盘缓冲区 解决哈希冲突的链地址算法中，关于插入新数据项的时间表述正确的是： 2022.02.14 计算机存储系统分为几个层次,你是如何理解分层存储的？ 三级层次结构，主要由 高速缓冲存储器 主存储器 辅助存储器 组成。 多线程同步和互斥有几种实现方法，都是什么？ 线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另外一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。 线程互斥是指对于共享的进程系统资源，每个线程访问时的排他性。当有若干个线程都要使用某一个共享资源时，任何时刻最多只允许一个线程去使用，其他线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。 线程间的同步方法大体可以分为两类：用户模式和内核模式。 用户模式： 原子操作（例如一个单一的全局变量），临界区 内核模式： 事件、信号量、互斥量 内核模式就是利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态， 而用户模式不需要切换内核态，只在用户态完成操作。 临界区： 通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。 互斥量： 为协调共同对一个共享资源的单独访问而设计。 信号量： 为控制一个具有有限数量的共享资源而设计。 事件： 用来通知线程有一些事件已发生，从而启动后继任务的开始。 mysql中innodb和myisam的区别 InnoDB支持事务，MyISAM不支持。 InnoDB支持外键，而MyISAM不支持。 InnoDB的B+树主键索引的叶子节点就是数据文件（聚集索引），辅助索引的叶子节点是主键的值（使用辅助索引需查找2次：①通过除主键以外的索引查询到主键的索引值，②再通过主键的索引值查找到对应的行数据。）； MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针，指向了真正的数据文件（无论是使用主键索引还是辅助索引都需要查找2次，一是找到地址，二是通过地址找到数据）。 InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。 而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件） Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高； 5.7以后的InnoDB支持全文索引了。 MyISAM表格可以被压缩后进行查询操作。 InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁。 InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。 InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有。 Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI。 Innodb：frm是表定义文件，ibd是数据文件 Myisam：frm是表定义文件，myd是数据文件，myi是索引文件 InnoDB为什么推荐使用自增ID作为主键？ 自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。 innodb引擎的4大特性 插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead) JDK为我们提供的工具 jps: 列出当前机器上正在运行的虚拟机进程 -p :仅仅显示VM 标示，不显示jar,class, main参数等信息. -m:输出主函数传入的参数. 下的hello 就是在执行程序时从命令行输入的参数 -l: 输出应用程序主类完整package名称或jar完整名称. -v: 列出jvm参数, -Xms20m -Xmx50m是启动程序指定的jvm参数 jstat 是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。 假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次，那命令应当是：jstat -gc 2764 250 20 常用参数： -class (类加载器) -compiler (JIT) -gc (GC堆状态) -gccapacity (各区大小) -gccause (最近一次GC统计和原因) -gcnew (新区统计) -gcnewcapacity (新区大小) -gcold (老区统计) -gcoldcapacity (老区大小) -gcpermcapacity (永久区大小) -gcutil (GC统计汇总) -printcompilation (HotSpot编译统计) 【gcutil 示例】 jinfo 查看和修改虚拟机的参数 jinfo –sysprops 可以查看由System.getProperties()取得的参数 jinfo –flag 未被显式指定的参数的系统默认值 jinfo –flags（注意s）显示虚拟机的参数 jinfo –flag +[参数] 可以增加参数，但是仅限于由java -XX:+PrintFlagsFinal –version查询出来且为manageable的参数 jinfo –flag -[参数] 可以去除参数 Thread.getAllStackTraces(); jmap 用于生成堆转储快照（一般称为heapdump或dump文件）。jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。和jinfo命令一样，jmap有不少功能在Windows平台下都是受限的，除了生成dump文件的-dump选项和用于查看每个类的实例、空间占用统计的-histo选项在所有操作系统都提供之外，其余选项都只能在Linux/Solaris下使用。 1、jmap -dump:live,format=b,file=heap.bin \\ Sun JDK提供jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。 2、 jmap -heap pid 查看java 堆（heap）使用情况 3、 jmap -histo pid 查看堆内存(histogram)中的对象数量，大小 num #instances #bytes class name 序号 实例个数 字节数 类名 ---------------------------------------------- 1: 3174877 107858256 [C 2: 3171499 76115976 java.lang.String 3: 1397884 38122240 [B 4: 214690 37785440 com.tongli.book.form.Book 5: 107345 18892720 com.tongli.book.form.Book 6: 65645 13953440 [Ljava.lang.Object; 7: 59627 7648416 8: 291852 7004448 java.util.HashMap$Entry 9: 107349 6871176 [[B .......... total 9150732 353969416 jhat jhat dump文件名 后屏幕显示“Server is ready.”的提示后，用户在浏览器中键入http://localhost：7000/就可以访问详情 jstack （Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。 在代码中可以用java.lang.Thread类的getAllStackTraces（）方法用于获取虚拟机中所有线程的StackTraceElement对象。使用这个方法可以通过简单的几行代码就完成jstack的大部分功能，在实际项目中不妨调用这个方法做个管理员页面，可以随时使用浏览器来查看线程堆栈。 管理远程进程需要在远程程序的启动参数中增加： -Djava.rmi.server.hostname=….. -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8888 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false visualvm 1：可以查看本地java进程内存，线程等 2：可以查看远程jvm进程内存，线程等情况 3：可以分析离线dump文件 插件中心地址 https://visualvm.github.io 但是注意版本问题，不同的JDK所带的visualvm是不一样的，下载插件时需要下对应的版本。 delete与truncate删除表中数据的区别 delete与truncate都可以用来删除表中数据 delete删除你表中数据之后，再次插入数据索引会接着之前的，而truncate删除表中后重新插入数据索引会从初始大小开始。 delete在删除数据后会将删除操作作为事务存储在日志中，这样就可以进行事务回滚。而 truncate则不可以事务回滚。 MD5是不是杂凑算法 MD5即 Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一，将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理。 MD5是输入不定长度信息，输出固定长度 128-bits 的算法。 经过程序流程，生成四个32位数据，最后联合起来成为一个 128-bits 散列。 基本方式为，求余、取余、调整长度、与链接变量进行循环运算，得出结果。 MD5 算法和加密算法都可以将信息转换为另外一种内容。 但是，MD5 算法对比 加密算法缺少了解密过程。 事实上，使用 加密算法加密后的消息是完整的，并且基于解密算法后，可以恢复原始数据。 而 MD5 算法得到的消息是不完整的，并且通过摘要的数据也无法得到原始数据。 所以，MD5 算法是杂凑算法，不是加密算法！ 数组的复制 System.arraycopy() public static void arraycopy(Object src,int srcPos,Object dest,int desPos,int length) Arrays.copyOf() public static int[] copyOf(int[] original, int newLength) 该方法目的应该是扩容，本质上内部还是调用了System.arraycopy()。 并发操作可能会产生哪几类数据不一致？用什么方法能避免各种不一致的情况？ 并发操作带来的数据不一致性包括三类： 丢失修改 不可重复读 读“脏”数据。 丢失修改（lostupdate）两个事务T1和T2读入同一数据并修改，T2提交的结果破坏了（覆盖了）T1提交的结果，导致T1的修改被丢失。 不可重复读（Non一RepeatableRead）不可重复读是指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果。 读“脏”数据（DirtyRead）读“脏”数据是指事务T1修改某一数据，并将其写回磁盘，事务几读取同一数据后，T1由于某种原因被撤销，这时T1已修改过的数据恢复原值，几读到的数据就与数据库中的数据不一致，则几读到的数据就为“脏”数据，即不正确的数据。 避免不一致性的方法和技术就是并发控制。最常用的技术是封锁技术。也可以用其他技术，例如在分布式数据库系统中可以采用时间戳方法来进行并发控制。 java对象序列化 序列化是将对象的状态信息转化为可以存储或传输的形式的过程。 Java提供的API有： java.io.Serializable java.io.Externalizable ObjectOutput ObjectInput ObjectOutputStream ObjectInputStream slf4j实现原理 slf4j是门面模式的典型应用。 https://www.cnblogs.com/xrq730/p/8619156.html 存储过程接受的参数是： IN：传入参数 OUT：传出参数 INOUT：传入传出参数 PL/SQL PL/SQL也是一种程序语言，叫做过程化SQL语言（Procedural Language/SQL）。PL/SQL是Oracle数据库对SQL语句的扩展。在普通SQL语句的使用上增加了编程语言的特点。 头部分 列外部分 执行部分：实现对数据的操作 声明部分 磁盘缓冲区 百度说法：磁盘的缓冲区是硬盘与外部总线交换数据的场所。 专业说法2种： 1指：在内存开辟的内存缓冲区，由程序自身所设置的一块内存空间，用来暂存从其他设备读入的数据或者是即将写入其他设备的数据； 2指：磁盘本身携带的一块随机存储区，大小通常在数MB到几十MB，这个是固化在硬盘内部的，它的作用和前一种类似，也是为了增加读写效率和保护硬盘，只是它是系统中的所有程序共享的，并且除了驱动程序外，通常的程序无法控制它。 总结 大多数情况下，程序不选择依赖磁盘本身携带的缓冲区，而是自己在内存占一块地方作为缓冲区。 解决哈希冲突的链地址算法中，关于插入新数据项的时间表述正确的是： https://blog.csdn.net/Jasminexjf/article/details/96108729 随装载因子线性增长 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-19 12:35:49 "},"chapter1/section2/":{"url":"chapter1/section2/","title":"2022.02.15","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 哈夫曼树是带权路径长度最短的树,路径上权值较大的结点离根较近. 一棵哈夫曼树的带权路径长度等于其中所有叶结点的带权路径长度之和 (后序线索树)的遍历仍需要栈的支持（不懂） 一棵哈夫曼树共有215个结点,对其进行哈夫曼编码,共能得到(108)个不同的码字 在ASC算法team日常开发中，常常面临一些数据结构的抉择，令人纠结。目前大家在策划一个FBI项目（Fast Binary Indexing），其中用到的词汇有6200条，词汇长度在10-15之间，词汇字符是英文字母，区分大小写。请在下面几个数据结构中选择一个使检索速度最快的： 在存储对称矩阵时，为了节省空间，通常可以用一个数组以行优先方式只存储上三角阵来实现。请问如果一个100*100的矩阵用上述方法来实现存储，在原矩阵中位置为选项中哪一项的元素可以通过访问数组下标为2017的位置来获得?( )数组和矩阵下标均从0开始。 对于一棵节点数为n、度为4的树来说那么树的高度至多是n-3 Hadoop的三种运行模式 采用败者树进行K路平衡归并时,总的(包括访外)归并效率与K hashmap为啥扩容因子是0.75 AOE网 凸多边形三角划分 若查找每个记录的概率均等，则在具有n个记录的连续顺序文件中采用顺序查找法查找一个记录，其平均查找长度ASL为 2022.02.15 哈夫曼树是带权路径长度最短的树,路径上权值较大的结点离根较近. True 一棵哈夫曼树的带权路径长度等于其中所有叶结点的带权路径长度之和 True (后序线索树)的遍历仍需要栈的支持（不懂） A : 前序遍历（中左右）、中序遍历（左中右）的最后访问的节点都是左或右叶节点， 叶节点是没有子树的，所以两个指针域空出来了，可以存放线索指针用于回溯。但是后续遍历（左右中），最后访问的是子树的根节点，子树根节点的两个指针域都指向子树了，所以不能空出来存放线索信息，只能借助栈存储。 一棵哈夫曼树共有215个结点,对其进行哈夫曼编码,共能得到(108)个不同的码字 A：哈夫曼树并不是满二叉树，是正则二叉树（也叫正规二叉树），即其中只有度为0和度为2的结点 因为n0 = n2 + 1，n = n0 + n2; 所以 n = 2n0 - 1，即n0 = (n + 1) / 2;叶子结点n0对应的即是不同的编码。 至于满二叉树当然也是正则二叉树的特例。 在ASC算法team日常开发中，常常面临一些数据结构的抉择，令人纠结。目前大家在策划一个FBI项目（Fast Binary Indexing），其中用到的词汇有6200条，词汇长度在10-15之间，词汇字符是英文字母，区分大小写。请在下面几个数据结构中选择一个使检索速度最快的： TRIE树，寻找子节点开销：1次运算/每字符 A：注解:又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。 在存储对称矩阵时，为了节省空间，通常可以用一个数组以行优先方式只存储上三角阵来实现。请问如果一个100*100的矩阵用上述方法来实现存储，在原矩阵中位置为选项中哪一项的元素可以通过访问数组下标为2017的位置来获得?( )数组和矩阵下标均从0开始。 (70，22)，该题为选择题，因此可以先获得公式，再带入试。 具体计算公式为：前n行的总和再加上当前行的个数，之后的和等于2017. 因为是个标准的等差数列，因此可以使用简单的高斯前n项求和， (100+100-(i-1))*i/2 + (j-i) = 2017 将答案中的选项带入试验。 注意该矩阵为对称矩阵，因此需要把(70,22)看成(22,70) 对于一棵节点数为n、度为4的树来说那么树的高度至多是n-3 度为4,高度为h的树，至少有h+3个节点。 Hadoop的三种运行模式 Hadoop是一个由Apache基金会所开发的分布式系统基础架构。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。 1.独立（本地）运行模式：无需任何守护进程，所有的程序都运行在同一个JVM上执行。在独立模式下调试MR程序非常高效方便。所以一般该模式主要是在学习或者开发阶段调试使用 。 2.伪分布式模式： Hadoop守护进程运行在本地机器上，模拟一个小规模的集群，换句话说，可以配置一台机器的Hadoop集群,伪分布式是完全分布式的一个特例。 3.完全分布式模式：Hadoop守护进程运行在一个集群上。 注意：所谓分布式要启动守护进程 ，即：使用分布式hadoop时，要先启动一些准备程序进程，然后才能使用比如start-dfs.sh start-yarn.sh。而本地模式不需要启动这些守护进程。 采用败者树进行K路平衡归并时,总的(包括访外)归并效率与K (有关) hashmap为啥扩容因子是0.75 https://www.cnblogs.com/aspirant/p/11470928.html 提高空间利用率和 减少查询成本的折中，主要是泊松分布，0.75的话碰撞最小， AOE网 在带权有向图中若以顶点表示事件，有向边表示活动，边上的权值表示该活动持续的时间，这样的图简称为AOE网。 与AOV网相反（见拓扑排序） 从始点到终点具有最大路径长度(该路径上的各个活动所持续的时间之和)的路径为关键路径。 关键活动组成了关键路径，关键路径是图中的最长路径，关键路径长度代表整个工期的最短完成时间，关键活动延期完成，必将导致关键路径长度增加，即整个工期的最短完成时间增加， 关键路径并不唯一，当有多条关键路径存在时，其中一条关键路径上的关键活动时间缩短，只能导致本条关键路径变成非关键路径，而无法缩短整个工期，因为其他关键路径没有变化， 凸多边形三角划分 在一个凸多边形中，通过若干条互不相交的对角线，把这个多边形划分成了若干个三角形。任务是 键盘上输入凸多边形的边数n，求不同划分的方案数f（n）？ 卡特兰数是组合数学中一个常出现在各种计数问题中的数列。 Dn+1=（4n-6)/n*Dn 则 D8=(4*7-6)/7 *D7 D7=(4*6-6)/6 *D6 D6=(4*5-6)/5 *D5 因为 D5=5 故 D8=132 若查找每个记录的概率均等，则在具有n个记录的连续顺序文件中采用顺序查找法查找一个记录，其平均查找长度ASL为 (n+1)/2 普通计算方法：https://blog.csdn.net/qq_27445903/article/details/108861737 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-19 12:35:54 "},"chapter1/section3/":{"url":"chapter1/section3/","title":"2022.02.16","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 等价类 JVM的client和server 持久化的目的 2022.02.16 等价类 https://zhuanlan.zhihu.com/p/112810758 所谓等价类，是输入条件的一个子集合，该输入集合中的数据对于揭示程序中的错误是等价的。从每一个子集中选取少数具有代表性的数据，从而生成测试用例。 等价类又分为有效等价类和无效等价类。 有效等价类代表对程序有效的输入， 而无效等价类则是其他任何可能的输入（即不正确的输入值）。 有效等价类和无效等价类都是使用等价类划分法设计用例时所必须的，因为被测程序若是正确的，就应该既能接受有效的输入，也能接受无效输入的考验。 目的 理想的测试，是从所有可能的输入中找出某个小的子集，并且是可能发现错误最多的子集。即：使用最少的测试数据，达到最好的测试质量（最高性价比）。 JVM的client和server Client：是针对为C/S结构而提供的虚拟机，针对桌面级应用的内存空间分配做的优化。C/S结构的程序和jvm交互的频率相对于B/S结构的频率要低很多。为了更合理地使用内存，分配给Client版的内存空间相对于Server版的要缩小了（打开java桌面应用时）。 Server：是针对为B/S结构而提供的虚拟机，针对浏览器端的内存分配做的优化。页面和jvm交互的频率高例如多线程并发。所以分配的内存空间较大，缺点就是可能造成空间的浪费（启动服务器时）。 Server启动慢运行快，Client启动快运行慢 重点：在部分JDK1.6版本后续的JDK版本（64位操作系统）中，-client参数已经不起作用,Server模式成为唯一。 持久化的目的 大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据）， 或者是为了防止系统故障而将数据备份到一个远程位置。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-02-22 12:00:18 "}}